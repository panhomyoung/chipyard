#  TSMC 28nm plugin for Hammer.
#
#  See LICENSE for licence details.

import sys
import os
import textwrap
from typing import List

from hammer.tech import HammerTechnology
from hammer.vlsi import HammerTool, HammerPlaceAndRouteTool, HammerDRCTool, MentorCalibreTool, TCLTool, HammerToolHookAction


class TSMCTech(HammerTechnology):
        """TSMC 28nm technology for Hammer."""

    def post_install_script(self) -> None:
        """Initialize the PDK support."""
        try:
            self.gds_tool = __import__('gdstk')
        except ImportError:
            self.logger.info("gdstk not found, falling back to gdspy...")
            try:
                self.gds_tool = __import__('gdspy')
                assert('1.4' in self.gds_tool.__version__)
            except (ImportError, AssertionError):
                self.logger.error("Check your gdspy v1.4 installation! Unable to handle TSMC PDK.")
                sys.exit()
        self.logger.info("Loaded TSMC 28nm PDK")
        
    def get_tech_par_hooks(self, tool_name: str) -> List[HammerToolHookAction]:
        hooks = {
            "innovus": [
                HammerTool.make_post_persistent_hook("init_design", tsmc_innovus_settings),
                HammerTool.make_post_insertion_hook("floorplan_design", tsmc_update_floorplan),
                # HammerTool.make_post_insertion_hook("write_design", tsmc_scale_final_gds),
            ]
        }
        return hooks.get(tool_name, [])

    def get_tech_drc_hooks(self, tool_name: str) -> List[HammerToolHookAction]:
        hooks = {
            "calibre": [
                HammerTool.make_replacement_hook("generate_drc_run_file", tsmc_generate_drc_run_file)
            ]
        }
        return hooks.get(tool_name, [])


def tsmc_innovus_settings(ht: HammerTool) -> bool:
    assert isinstance(ht, HammerPlaceAndRouteTool), "Innovus settings only for par"
    assert isinstance(ht, TCLTool), "innovus settings can only run on TCL tools"
    ht.append('''
set_db route_design_bottom_routing_layer 2
set_db route_design_top_routing_layer 10
set_db timing_analysis_async_checks no_async
set_db generate_special_via_rule_preference { M10_M9widePWR1p4 M9_M8widePWR1p4 M8_M7widePWR1p2 M7_M6widePWR1p2 M6_M5widePWR1p0 M5_M4widePWR1p0 M4_M3widePWR0p9 M3_M2widePWR0p9 }
set_db route_design_with_via_in_pin true
''')
    return True


def tsmc_update_floorplan(ht: HammerTool) -> bool:
    assert isinstance(ht, HammerPlaceAndRouteTool), "tsmc_update_floorplan can only run on par"
    assert isinstance(ht, TCLTool), "tsmc_update_floorplan can only run on TCL tools"
    ht.append('''
add_tracks -honor_pitch -offsets {
    M1 vert 0.050
    M2 horiz 0.050
    M3 vert 0.050
    M4 horiz 0.050
    M5 vert 0.050
    M6 horiz 0.070
    M7 vert 0.070
    M8 horiz 0.090
    M9 vert 0.090
    M10 horiz 0.090
}
set core_lly [get_db current_design .core_bbox.ll.y]
set core_ury [expr [get_db current_design .core_bbox.ur.y] - 1.10]
set botrow [get_db rows -if {.rect.ll.y == $core_lly}]
set toprow [get_db rows -if {.rect.ur.y > $core_ury}]
create_place_blockage -area [get_db $botrow .rect] -name ROW_BLOCK_BOT
create_place_blockage -area [get_db $toprow .rect] -name ROW_BLOCK_TOP
''')
    return True


def tsmc_scale_final_gds(ht: HammerTool) -> bool:
    assert isinstance(ht, HammerPlaceAndRouteTool), "tsmc_scale_final_gds can only run on par"
    assert isinstance(ht, TCLTool), "tsmc_scale_final_gds can only run on TCL tools"
    cadence_output_gds_name = ht.output_gds_filename  # type: ignore
    ht.append('''
set env(LD_LIBRARY_PATH) [join [lsearch -not -all -inline [split $env(LD_LIBRARY_PATH) ":"] "*INNOVUS*"] ":"]
tsmc_gds_scale {stdcells_file} {gds_file}
'''.format(stdcells_file=os.path.join(ht.technology.cache_dir, 'stdcells.txt'),
           gds_file=cadence_output_gds_name))
    return True


def tsmc_generate_drc_run_file(ht: HammerTool) -> bool:
    assert isinstance(ht, HammerDRCTool), "tsmc_generate_drc_run_file can only run on drc"
    assert isinstance(ht, MentorCalibreTool), "tsmc_generate_drc_run_file can only run on a Calibre tool"
    ht_drc_run_file = ht.drc_run_file  # type: ignore
    ht_max_drc_results = ht.max_drc_results  # type: ignore
    ht_virtual_connect_colon = ht.virtual_connect_colon  # type: ignore

    new_layout_file = os.path.join(ht.run_dir, 'test.gds')
    if not os.path.lexists(new_layout_file):
        os.symlink(os.path.splitext(ht.layout_file)[0] + '_drc.gds', new_layout_file)
    ht.layout_file = new_layout_file

    with open(ht_drc_run_file, "w") as f:
        f.write(textwrap.dedent("""
        // Generated by HAMMER for TSMC 28nm

        DRC MAXIMUM RESULTS {max_results}
        DRC MAXIMUM VERTEX 4096

        DRC CELL NAME YES CELL SPACE XFORM

        VIRTUAL CONNECT COLON {virtual_connect}
        VIRTUAL CONNECT REPORT NO
        """).format(
            max_results=ht_max_drc_results,
            virtual_connect="YES" if ht_virtual_connect_colon else "NO",
        ))
        for rule in ht.get_drc_decks():
            f.write("INCLUDE \"{}\"\n".format(rule.path))
        if len(ht.drc_rules_to_run()) > 0:
            f.write("\nDRC SELECT CHECK\n")
        for check in ht.drc_rules_to_run():
            f.write("\t\"{}\"\n".format(check))
        f.write("\nDRC ICSTATION YES\n")
        f.write(ht.get_additional_drc_text())
    return True


tech = TSMCTech()
