#!/usr/bin/env python3
#  Script to generate the TSMC28 dummy SRAM cache.
#
#  Based on user-provided TSMC SRAM port information.

import sys
import re
from typing import List, Dict, Any, Callable, Optional, Tuple

def generate_new_single_port_sram(match: re.Match, sram_name: str) -> str:
    depth = match.group(2)
    width = match.group(3)
    mux_val = match.group(4)

    # Note: Port polarities are assumed based on standard conventions (e.g., 'B' suffix means active-low).
    # Please verify against the memory compiler documentation.
    # Extra ports like BIST, RTSEL, WTSEL are set to a default constant value 0.
    return f"""{{
  "type" : "sram",
  "name" : "{sram_name}",
  "vt" : "TSMC",
  "depth" : "{depth}",
  "width" : {width},
  "mux" : {mux_val},
  "family" : "1RW",
  "mask" : "true",
  "ports" : [ {{
    "address port name" : "A",
    "address port polarity" : "active high",
    "clock port name" : "CLK",
    "clock port polarity" : "positive edge",
    "write enable port name" : "WEB",
    "write enable port polarity" : "active low",
    "output port name" : "Q",
    "output port polarity" : "active high",
    "input port name" : "D",
    "input port polarity" : "active high",
    "chip enable port name" : "CEB",
    "chip enable port polarity" : "active low",
    "mask port name" : "BWEB",
    "mask port polarity" : "active low",
    "mask granularity" : 1
  }} ],
  "extra_ports": [
    {{ "name": "SLP", "type": "constant", "value": 0, "width": 1 }},
    {{ "name": "SD", "type": "constant", "value": 0, "width": 1 }},
    {{ "name": "BIST", "type": "constant", "value": 0, "width": 1 }},
    {{ "name": "RTSEL", "type": "constant", "value": 0, "width": 1 }},
    {{ "name": "WTSEL", "type": "constant", "value": 0, "width": 1 }},
    {{ "name": "CEBM", "type": "constant", "value": 0, "width": 1 }},
    {{ "name": "WEBM", "type": "constant", "value": 0, "width": 1 }},
    {{ "name": "AM", "type": "constant", "value": 0, "width": {len(depth)} }},
    {{ "name": "DM", "type": "constant", "value": 0, "width": {width} }},
    {{ "name": "BWEBM", "type": "constant", "value": 0, "width": 1 }}
  ]
}}"""

def generate_new_dual_port_sram(match: re.Match, sram_name: str) -> str:
    """
    Generates the JSON entry for the new dual-port SRAM.
    e.g., TSDN28HPCPUHDB32X16M4MWA
    """
    depth = match.group(2)
    width = match.group(3)
    mux_val = match.group(4)

    # This is a 1-Read-1-Write (1R1W) SRAM with two ports: A and B.
    # They share a common clock signal 'CLK'.
    return f"""{{
  "type" : "sram",
  "name" : "{sram_name}",
  "vt" : "TSMC",
  "depth" : "{depth}",
  "width" : {width},
  "mux" : {mux_val},
  "family" : "2RW",
  "mask" : "true",
  "ports" : [
    {{
      "address port name" : "AA",
      "address port polarity" : "active high",
      "clock port name" : "CLK",
      "clock port polarity" : "positive edge",
      "write enable port name" : "WEBA",
      "write enable port polarity" : "active low",
      "output port name" : "QA",
      "output port polarity" : "active high",
      "input port name" : "DA",
      "input port polarity" : "active high",
      "chip enable port name" : "CEBA",
      "chip enable port polarity" : "active low",
      "mask port name" : "BWEBA",
      "mask port polarity" : "active low",
      "mask granularity" : 1
    }},
    {{
      "address port name" : "AB",
      "address port polarity" : "active high",
      "clock port name" : "CLK",
      "clock port polarity" : "positive edge",
      "write enable port name" : "WEBB",
      "write enable port polarity" : "active low",
      "output port name" : "QB",
      "output port polarity" : "active high",
      "input port name" : "DB",
      "input port polarity" : "active high",
      "chip enable port name" : "CEBB",
      "chip enable port polarity" : "active low",
      "mask port name" : "BWEBB",
      "mask port polarity" : "active low",
      "mask granularity" : 1
    }}
  ],
  "extra_ports": [
    {{ "name": "RTSEL", "type": "constant", "value": 0, "width": 1 }},
    {{ "name": "WTSEL", "type": "constant", "value": 0, "width": 1 }},
    {{ "name": "PTSEL", "type": "constant", "value": 0, "width": 1 }},
    {{ "name": "AWT", "type": "constant", "value": 0, "width": 1 }}
  ]
}}"""

def generate_original_sram(match: re.Match, sram_name: str) -> str:
    """
    Generates the JSON entry for the original SRAM type for backward compatibility.
    e.g., TEM5N28HPCPLVTA64X20M4SWSO
    """
    depth = match.group(2)
    width = match.group(3)
    mux_val = match.group(4)
    return f"""{{
  "type" : "sram",
  "name" : "{sram_name}",
  "vt" : "TSMC",
  "depth" : "{depth}",
  "width" : {width},
  "mux" : {mux_val},
  "family" : "1RW",
  "mask" : "true",
  "ports" : [ {{
    "address port name" : "A",
    "address port polarity" : "active high",
    "clock port name" : "CLK",
    "clock port polarity" : "positive edge",
    "write enable port name" : "WEB",
    "write enable port polarity" : "active low",
    "output port name" : "Q",
    "output port polarity" : "active high",
    "input port name" : "D",
    "input port polarity" : "active high",
    "chip enable port name" : "CEB",
    "chip enable port polarity" : "active low",
    "mask port name" : "BWEB",
    "mask port polarity" : "active low",
    "mask granularity" : 1
  }} ],
  "extra_ports": [
    {{ "name": "SLP", "width": 1, "type": "constant", "value": 0 }},
    {{ "name": "SD", "width": 1, "type": "constant", "value": 0 }}
  ]
}}"""

# ==============================================================================
#  SRAM DEFINITIONS
#  List of tuples, where each tuple contains a compiled regex pattern and the
#  corresponding function to generate the JSON for that SRAM type.
#  The script will try to match them in order.
# ==============================================================================

SRAM_DEFINITIONS: List[Tuple[re.Pattern, Callable[[re.Match, str], str]]] = [
    # Definition for the new Single-Port SRAM
    (
        re.compile(r"^(TS1N28HPCPUHDHVTB)(\d+)X(\d+)M(\d+)(SWBSO)$"),
        generate_new_single_port_sram
    ),
    # Definition for the new Dual-Port SRAM
    (
        re.compile(r"^(TSDN28HPCPUHDB)(\d+)X(\d+)M(\d+)(MWA)$"),
        generate_new_dual_port_sram
    ),
    # Definition for the original SRAM (for backward compatibility)
    (
        re.compile(r"^(TEM5N28HPCPLVTA)(\d+)X(\d+)M(\d+)(SWSO)$"),
        generate_original_sram
    ),
]

def main(args: List[str]) -> int:
    if len(args) != 3:
        print("Usage: ./sram-cache-gen.py list-of-srams-1-per-line.txt output-file.json")
        return 1

    input_file_path = sys.argv[1]
    output_file_path = sys.argv[2]

    try:
        with open(input_file_path) as f:
            list_of_srams = [line.strip() for line in f]
    except FileNotFoundError:
        print(f"Error: Input file not found at '{input_file_path}'", file=sys.stderr)
        return 1

    json_entries: List[str] = []
    unsupported_srams: List[str] = []

    for sram_name in list_of_srams:
        if not sram_name:  # Skip empty lines
            continue

        matched = False
        for pattern, generator_func in SRAM_DEFINITIONS:
            match = pattern.match(sram_name)
            if match:
                json_entries.append(generator_func(match, sram_name))
                matched = True
                break  # Found a match, move to the next SRAM name

        if not matched:
            unsupported_srams.append(sram_name)

    # Write the JSON output to the file
    if not json_entries:
        print("Warning: No valid SRAM entries were generated.", file=sys.stderr)
        json_str = "[]\n"
    else:
        # Join all individual JSON strings with a comma and newline
        json_str = "[\n" + ",\n".join(json_entries) + "\n]\n"

    try:
        with open(output_file_path, "w") as f:
            f.write(json_str)
    except IOError as e:
        print(f"Error: Could not write to output file '{output_file_path}': {e}", file=sys.stderr)
        return 1
    
    # Print summary report
    print(f"Successfully generated JSON for {len(json_entries)} SRAM(s) in {output_file_path}")
    if unsupported_srams:
        print("\nThe following SRAM formats were not supported and were skipped:", file=sys.stderr)
        for name in unsupported_srams:
            print(f"  - {name}", file=sys.stderr)

    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv))